{######################################################################}
{# Copyright (c) 2010-2016, Fabric Software Inc. All rights reserved. #}
{######################################################################}
{% extends "generate/decl/decl.impls.kl" %}
{% block body %}
{{decl.render_method_impls('kl')}}
////////////////////////////////////////////////////////////////////////
// {{decl.type_info.const_ptr.kl.name}}
// {{decl.type_info.mutable_ptr.kl.name}}
// {{decl.type_info.const_ref.kl.name}}
// {{decl.type_info.mutable_ref.kl.name}}
// Wrapper methods
////////////////////////////////////////////////////////////////////////

// Given an io value, take a pointer to the value
{{decl.type_info.const_ptr.kl.name}}(io {{decl.type_info.direct.kl.name}} value) {
  this.ptr = value.data();
}

// Given an external array, take a pointer to the first element
{{decl.type_info.const_ptr.kl.name}}({{decl.type_info.direct.kl.name}} array<>) {
  this.ptr = array.data();
}

// Is valid.  Check for null pointer
Boolean {{decl.type_info.const_ptr.kl.name}}.ptrIsValid() {
  return !!this.ptr;
}

Boolean({{decl.type_info.const_ptr.kl.name}} ptr) {
  this = ptr.ptrIsValid();
}

// Indexing operation
{{decl.type_info.const_ref.kl.name}} {{decl.type_info.const_ptr.kl.name}}.ptrGetAt(Index i) {
  return {{decl.type_info.const_ref.kl.name}}(this, i);
}

// Deref the pointer
{{decl.type_info.const_ref.kl.name}} {{decl.type_info.const_ptr.kl.name}}.ptrDeref() {
  return this.ptrGetAt(0);
}

{% if decl.type_info.direct.kl.name.base == 'SInt8' %}
// Given a String, take a pointer to the bytes of the string
{{decl.type_info.const_ptr.kl.name}}(String s) {
  this.ptr = s.data();
}

// Convert to a string
// Note that this can potentially crash.  Converting a {{decl.type_info.const_ptr.kl.name}} to
// a String is not always safe, just as it is not always safe in C++
{{decl.type_info.const_ptr.kl.name}}.appendDesc(io String s) {
  Count size = 0;
  while (this.ptrGetAt(size))
    ++size;
  UInt8 bytes<>(this.ptr, size);
  String ss;
  ss.setFrom(bytes);
  s += ss;
}
{% else %}
// Convert to a string
{{decl.type_info.const_ptr.kl.name}}.appendDesc(io String s) {
  s += this.ptr;
}
{% endif %}

// Given an io value, take a pointer to the value
{{decl.type_info.mutable_ptr.kl.name}}(io {{decl.type_info.direct.kl.name}} value) {
  this.ptr = value.data();
}

// Given an io external array, take a pointer to the first element
{{decl.type_info.mutable_ptr.kl.name}}({{decl.type_info.direct.kl.name}} ea<>) {
  this.ptr = ea.data();
}

// Same as for {{decl.type_info.const_ptr.kl.name}}, but returning a non-const ref
{{decl.type_info.mutable_ref.kl.name}} {{decl.type_info.mutable_ptr.kl.name}}.ptrGetAt(Index i) {
  return {{decl.type_info.mutable_ref.kl.name}}(this.ptr.offset(i)->{ {{decl.type_info.direct.kl.name}} });
}

// Same as for {{decl.type_info.const_ptr.kl.name}}, but returning a non-const ref
{{decl.type_info.mutable_ref.kl.name}} {{decl.type_info.mutable_ptr.kl.name}}.ptrDeref() {
  return this.ptrGetAt(0);
}

// Set the value at an offset into the array
{{decl.type_info.mutable_ptr.kl.name}}.ptrSetAt(Index i, {{decl.type_info.direct.kl.name}} v) {
  this.ptr.offset(i)->{ {{decl.type_info.direct.kl.name}} } = v;
}

// Create a reference to a character
// Since {{decl.type_info.direct.kl.name}} is passed by value, we need a trick to own
// storage for it.  This would be necessary for other "pass by value"
// types but never for structures, which we can always take a pointer to.
{{decl.type_info.const_ref.kl.name}}({{decl.type_info.direct.kl.name}} value) {
  this.ptr = this.value.data();
  this.value = value;
  this.is_local = true;
}

// Copy ctor
{{decl.type_info.const_ref.kl.name}}({{decl.type_info.const_ref.kl.name}} that) {
  if (that.is_local) {
    this.ptr = this.value.data();
    this.value = that.value;
    this.is_local = true;
  }
  else this.ptr = that.ptr;
}

// Assigment
{{decl.type_info.const_ref.kl.name}}.=({{decl.type_info.const_ref.kl.name}} that) {
  if (that.is_local) {
    this.ptr = this.value.data();
    this.value = that.value;
    this.is_local = true;
  }
  else this.ptr = that.ptr;
}

// Construct from an io {{decl.type_info.direct.kl.name}}; just take the pointer
{{decl.type_info.const_ref.kl.name}}(io {{decl.type_info.direct.kl.name}} value) {
  this.ptr = value.data();
}

// Construct from a {{decl.type_info.const_ptr.kl.name}} and an offset; used
// for {{decl.type_info.const_ptr.kl.name}}.ptrGetAt
{{decl.type_info.const_ref.kl.name}}({{decl.type_info.const_ptr.kl.name}} ptr, Index offset) {
  this.ptr = ptr.ptr.offset(offset);
}

// Get the {{decl.type_info.direct.kl.name}} value
{{decl.type_info.direct.kl.name}} {{decl.type_info.const_ref.kl.name}}.refGet() {
  return this.ptr->{ {{decl.type_info.direct.kl.name}} };
}

// Cast from {{decl.type_info.const_ref.kl.name}} to {{decl.type_info.direct.kl.name}}
{{decl.type_info.direct.kl.name}}({{decl.type_info.const_ref.kl.name}} ref) {
  this = ref.refGet();
}

// Convert to String
{{decl.type_info.const_ref.kl.name}}.appendDesc(io String s) {
  s += this.refGet();
}

{% if decl.type_info.direct.kl.name.base != 'Boolean' %}

// Convert to Boolean
Boolean({{decl.type_info.const_ref.kl.name}} ref) {
  this = Boolean(ref.refGet());
}
{% endif %}

// Construct a {{decl.type_info.mutable_ref.kl.name}} from an io {{decl.type_info.direct.kl.name}}
{{decl.type_info.mutable_ref.kl.name}}(io {{decl.type_info.direct.kl.name}} value) {
  this.ptr = value.data();
}

// Set the value
{{decl.type_info.mutable_ref.kl.name}}.refSet({{decl.type_info.direct.kl.name}} value) {
  this.ptr->{ {{decl.type_info.direct.kl.name}} } = value;
}

// Assignment of {{decl.type_info.direct.kl.name}}
{{decl.type_info.mutable_ref.kl.name}}.=({{decl.type_info.direct.kl.name}} value) {
  this.refSet(value);
}

// Convert to String
{{decl.type_info.mutable_ref.kl.name}}.appendDesc(io String s) {
  s += this.refGet();
}

{% endblock body %}
