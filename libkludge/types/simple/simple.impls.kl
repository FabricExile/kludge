{######################################################################}
{# Copyright (c) 2010-2016, Fabric Software Inc. All rights reserved. #}
{######################################################################}
{% extends "generate/decl/decl.impls.kl" %}
{% block body %}
struct {{decl.kl_type_name}}ConstPtr permits {{decl.kl_type_name}}ConstRef {
  protected Data ptr; // actual {{decl.cpp_type_expr}} const *
};

struct {{decl.kl_type_name}}Ptr : {{decl.kl_type_name}}ConstPtr {
};

struct {{decl.kl_type_name}}ConstRef {
  protected Data ptr; // actual {{decl.cpp_type_expr}} const *
  protected {{decl.kl_type_name}} value; // used in the "local" case where we construct a {{decl.kl_type_name}}ConstRef from a {{decl.kl_type_name}}
  protected Boolean is_local; // ""
};

struct {{decl.kl_type_name}}Ref : {{decl.kl_type_name}}ConstRef {
};

// Given an io value, take a pointer to the value
{{decl.kl_type_name}}ConstPtr(io {{decl.kl_type_name}} value) {
  this.ptr = value.data();
}

// Given an external array, take a pointer to the first element
{{decl.kl_type_name}}ConstPtr({{decl.kl_type_name}} array<>) {
  this.ptr = array.data();
}

// Is valid.  Check for null pointer
Boolean {{decl.kl_type_name}}ConstPtr.isValid() {
  return !!this.ptr;
}

Boolean({{decl.kl_type_name}}ConstPtr ptr) {
  this = ptr.isValid();
}

// Indexing operation
{{decl.kl_type_name}}ConstRef {{decl.kl_type_name}}ConstPtr.getAt(Index i) {
  return {{decl.kl_type_name}}ConstRef(this, i);
}

// Deref the pointer
{{decl.kl_type_name}}ConstRef {{decl.kl_type_name}}ConstPtr.deref() {
  return this.getAt(0);
}

{% if decl.kl_type_name == 'SInt8' %}
// Given a String, take a pointer to the bytes of the string
{{decl.kl_type_name}}ConstPtr(String s) {
  this.ptr = s.data();
}

// Convert to a string
// Note that this can potentially crash.  Converting a {{decl.kl_type_name}}ConstPtr to
// a String is not always safe, just as it is not always safe in C++
{{decl.kl_type_name}}ConstPtr.appendDesc(io String s) {
  Count size = 0;
  while (this.getAt(size))
    ++size;
  UInt8 bytes<>(this.ptr, size);
  String ss;
  ss.setFrom(bytes);
  s += ss;
}
{% else %}
// Convert to a string
{{decl.kl_type_name}}ConstPtr.appendDesc(io String s) {
  s += this.ptr;
}
{% endif %}

// Given an io value, take a pointer to the value
{{decl.kl_type_name}}Ptr(io {{decl.kl_type_name}} value) {
  this.ptr = value.data();
}

// Given an io external array, take a pointer to the first element
{{decl.kl_type_name}}Ptr({{decl.kl_type_name}} ea<>) {
  this.ptr = ea.data();
}

// Same as for {{decl.kl_type_name}}ConstPtr, but returning a non-const ref
{{decl.kl_type_name}}Ref {{decl.kl_type_name}}Ptr.getAt(Index i) {
  return {{decl.kl_type_name}}Ref(this.ptr.offset(i)->{ {{decl.kl_type_name}} });
}

// Same as for {{decl.kl_type_name}}ConstPtr, but returning a non-const ref
{{decl.kl_type_name}}Ref {{decl.kl_type_name}}Ptr.deref() {
  return this.getAt(0);
}

// Set the value at an offset into the array
{{decl.kl_type_name}}Ptr.setAt(Index i, {{decl.kl_type_name}} v) {
  {{decl.kl_type_name}}Ref(this.ptr.offset(i)->{ {{decl.kl_type_name}} }).set(v);
}

// Create a reference to a character
// Since {{decl.kl_type_name}} is passed by value, we need a trick to own
// storage for it.  This would be necessary for other "pass by value"
// types but never for structures, which we can always take a pointer to.
{{decl.kl_type_name}}ConstRef({{decl.kl_type_name}} value) {
  this.ptr = this.value.data();
  this.value = value;
  this.is_local = true;
}

// Copy ctor
{{decl.kl_type_name}}ConstRef({{decl.kl_type_name}}ConstRef that) {
  if (that.is_local) {
    this.ptr = this.value.data();
    this.value = that.value;
    this.is_local = true;
  }
  else this.ptr = that.ptr;
}

// Assigment
{{decl.kl_type_name}}ConstRef.=({{decl.kl_type_name}}ConstRef that) {
  if (that.is_local) {
    this.ptr = this.value.data();
    this.value = that.value;
    this.is_local = true;
  }
  else this.ptr = that.ptr;
}

// Construct from an io {{decl.kl_type_name}}; just take the pointer
{{decl.kl_type_name}}ConstRef(io {{decl.kl_type_name}} value) {
  this.ptr = value.data();
}

// Construct from a {{decl.kl_type_name}}ConstPtr and an offset; used
// for {{decl.kl_type_name}}ConstPtr.getAt
{{decl.kl_type_name}}ConstRef({{decl.kl_type_name}}ConstPtr ptr, Index offset) {
  this.ptr = ptr.ptr.offset(offset);
}

// Get the {{decl.kl_type_name}} value
{{decl.kl_type_name}} {{decl.kl_type_name}}ConstRef.get() {
  return this.ptr->{ {{decl.kl_type_name}} };
}

// Cast from {{decl.kl_type_name}}ConstRef to {{decl.kl_type_name}}
{{decl.kl_type_name}}({{decl.kl_type_name}}ConstRef ref) {
  this = ref.get();
}

// Convert to String
{{decl.kl_type_name}}ConstRef.appendDesc(io String s) {
  s += this.get();
}

{% if decl.kl_type_name != 'Boolean' %}

// Convert to Boolean
Boolean({{decl.kl_type_name}}ConstRef ref) {
  this = Boolean(ref.get());
}
{% endif %}

// Construct a {{decl.kl_type_name}}Ref from an io {{decl.kl_type_name}}
{{decl.kl_type_name}}Ref(io {{decl.kl_type_name}} value) {
  this.ptr = value.data();
}

// Set the value
{{decl.kl_type_name}}Ref.set({{decl.kl_type_name}} value) {
  this.ptr->{ {{decl.kl_type_name}} } = value;
}

// Assignment of {{decl.kl_type_name}}
{{decl.kl_type_name}}Ref.=({{decl.kl_type_name}} value) {
  this.set(value);
}

// Convert to String
{{decl.kl_type_name}}Ref.appendDesc(io String s) {
  s += this.get();
}

{% endblock body %}
