#ifndef __KL2EDK_AUTOGEN_{{ t.type_name }}_impl__
#define __KL2EDK_AUTOGEN_{{ t.type_name }}_impl__

#ifdef KL2EDK_INCLUDE_MESSAGES
  #pragma message ( "Including '{{ t.type_name }}_impl.h'" )
#endif

////////////////////////////////////////////////////////////////
// THIS FILE IS AUTOMATICALLY GENERATED -- DO NOT MODIFY!!
////////////////////////////////////////////////////////////////
// Generated by kl2edk version {{ version_full }}
////////////////////////////////////////////////////////////////

#include <FabricEDK.h>
#if FABRIC_EDK_VERSION_MAJ != {{ version_maj }} || FABRIC_EDK_VERSION_MIN != {{ version_min }}
# error "This file needs to be rebuilt for the current EDK version!"
#endif

#include "global.h"

{% for d in t.depends %}
#include "{{ d }}.h"
{% endfor %}
#include "{{ t.type_name }}.h"

namespace Fabric { namespace EDK { namespace KL {

  inline void {{ t.type_name }}::ConstructEmpty( {{ t.type_name }} *self )
  {
    self->m_bits = 0;
  }
  
  inline void {{ t.type_name }}::ConstructCopy( {{ t.type_name }} *self, {{ t.type_name }} const *other )
  {
    if ( (self->m_bits = other->m_bits) )
      AtomicUInt32Increment( &self->m_bits->objectCorePtr->refCount );
  }
  
  inline void {{ t.type_name }}::AssignCopy( {{ t.type_name }} *self, {{ t.type_name }} const *other )
  {
    if ( self->m_bits != other->m_bits )
    {
      Destruct( self );
      ConstructCopy( self, other );
    }
  }
  
  inline void {{ t.type_name }}::Destruct( {{ t.type_name }} *self )
  {
    if ( self->m_bits
      && AtomicUInt32DecrementAndGetValue( &self->m_bits->objectCorePtr->refCount ) == 0 )
    {
      self->m_bits->objectCorePtr->lTableSwapPtrPtr->get()->lifecycleDestroy(
        &self->m_bits->objectCorePtr
        );
    }
  }
  
  inline {{ t.type_name }}::{{ t.type_name }}()
  {
    ConstructEmpty( this );
  }
  
  inline {{ t.type_name }}::{{ t.type_name }}( {{ t.type_name }} const &that )
  {
    ConstructCopy( this, &that );
  }
  
  inline {{ t.type_name }} &{{ t.type_name }}::operator =( {{ t.type_name }} const &that )
  {
    AssignCopy( this, &that );
    return *this;
  }
  
  inline {{ t.type_name }}::~{{ t.type_name }}()
  {
    Destruct( this );
  }
  
  inline void {{ t.type_name }}::appendDesc( String::IOParam string ) const
  {
    if ( m_bits )
      m_bits->objectCorePtr->lTableSwapPtrPtr->get()->appendDesc( &m_bits->objectCorePtr, string );
    else string.append( "null", 4 );
  }
  
  inline bool {{ t.type_name }}::isValid() const
  {
    return !!m_bits;
  }
  
  inline {{ t.type_name }}::operator bool() const
  {
    return isValid();
  }
  
  inline bool {{ t.type_name }}::operator !() const
  {
    return !isValid();
  }
  
  inline bool {{ t.type_name }}::operator ==( INParam that )
  {
    return m_bits == that.m_bits;
  }
  
  inline bool {{ t.type_name }}::operator !=( INParam that )
  {
    return m_bits != that.m_bits;
  }
 
{% for method in t.methods %}
  inline
  {% if method.ret_type_name %}
  {{ method.ret_type_name_cpp }}
  {% else %}
  void
  {% endif %}
  {{ t.type_name }}::{{ method.name }}(
  {% for param in method.params %}
    {% if not loop.first %}
,
    {% endif %}
    Traits< {{ param.type_name_cpp }} >::{{ param.usage_cpp }} {{ param.name -}}
    {% if loop.last %}

    {% endif %}
  {% endfor %}
    ){% if method.usage == "in" %} const{% endif %}

  {
{% if method.ret_type_name %}
    {{ method.ret_type_name_cpp }} _result;
{% endif %}
  {% if manager.uses_returnval(method.ret_type_name) %}    _result ={% endif %}
    m_bits->vTableSwapPtrPtr->get()->{{ method.name }}_{{ method.hash() }}(
  {% if method.ret_type_name and not manager.uses_returnval(method.ret_type_name) %}      _result,
  {% endif %}
      {{ "&m_bits->objectCorePtr" -}}
  {% for param in method.params %}
,
      {{ param.name -}}
  {% endfor %}
 );
{% if method.ret_type_name %}
    return _result;
{% endif %}
  }

{% endfor %}
}}}

#endif // __KL2EDK_AUTOGEN_{{ t.type_name }}_impl__
